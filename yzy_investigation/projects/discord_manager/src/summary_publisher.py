"""Discord Summary Publisher module.

This module provides functionality to publish Discord summary bullet points 
to a specified Discord channel, taking summaries generated by the message_summarizer
and posting them as individual messages for improved readability.
"""

import os
import sys
import asyncio
import re
import json
from pathlib import Path
from typing import List, Dict, Any, Optional, Tuple
import argparse
import logging
from datetime import datetime, timedelta

import discord
from dotenv import load_dotenv

# Add the project root to the Python path
project_root = Path(__file__).parent.parent.parent.parent
sys.path.append(str(project_root))

# Configure logging
logging.basicConfig(
    level=logging.INFO,
    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s'
)
logger = logging.getLogger(__name__)

class SummaryPublisher:
    """Class for publishing summary bullet points to Discord channels."""
    
    # Discord message character limit
    MAX_MESSAGE_LENGTH = 2000  # Setting to 2000 to be safe (actual limit is 4000)
    
    def __init__(
        self, 
        token: Optional[str] = None,
        server_id: Optional[int] = None,
        channel_id: Optional[int] = None,
        test_mode: bool = True
    ):
        """
        Initialize the SummaryPublisher.
        
        Args:
            token: Discord bot token. If None, will use DISCORD_BOT_TOKEN env var.
            server_id: Discord server ID. If None, will use appropriate env var.
            channel_id: Discord channel ID. If None, will use appropriate env var.
            test_mode: If True, use test server and channel IDs from env vars.
        """
        # Load environment variables if needed
        load_dotenv()
        
        # Set up Discord bot token
        self.token = token or os.environ.get("DISCORD_BOT_TOKEN")
        if not self.token:
            raise ValueError("Discord bot token not provided and DISCORD_BOT_TOKEN not set in environment")
        
        # Set up server and channel IDs based on test mode
        if test_mode:
            self.server_id = server_id or int(os.environ.get("DISCORD_SERVER_ID_TEST", 0))
            self.channel_id = channel_id or int(os.environ.get("DISCORD_CHANNEL_ID_TEST", 0))
            logger.info("Running in TEST mode")
        else:
            self.server_id = server_id or int(os.environ.get("DISCORD_SERVER_ID", 0))
            self.channel_id = channel_id or int(os.environ.get("DISCORD_CHANNEL_ID", 0))
        
        if self.server_id == 0:
            raise ValueError(f"Discord server ID not provided and {'DISCORD_SERVER_ID_TEST' if test_mode else 'DISCORD_SERVER_ID'} not set in environment")
        
        if self.channel_id == 0:
            raise ValueError(f"Discord channel ID not provided and {'DISCORD_CHANNEL_ID_TEST' if test_mode else 'DISCORD_CHANNEL_ID'} not set in environment")
        
        # Configure intents for Discord client
        intents = discord.Intents.default()
        intents.message_content = True
        self.client = discord.Client(intents=intents)
        self.is_ready = asyncio.Event()
        self.test_mode = test_mode
        
        # Set up an event for when the client is ready
        @self.client.event
        async def on_ready():
            logger.info(f"Bot logged in as {self.client.user}")
            self.is_ready.set()
    
    async def parse_summary_file(self, file_path: str) -> Tuple[str, List[Dict[str, Any]]]:
        """
        Parse a summary JSON file and extract topics.
        
        Args:
            file_path: Path to the summary JSON file
            
        Returns:
            Tuple containing (overview text, list of topic dictionaries)
        """
        logger.info(f"Opening file: {file_path}")
        with open(file_path, 'r', encoding='utf-8') as f:
            content = f.read()
            
        logger.info(f"File content length: {len(content)} characters")
        
        # Parse the JSON content
        try:
            data = json.loads(content)
            logger.info(f"Successfully parsed JSON with {len(data)} entries")
            
            # Extract all topics from the nested structure
            all_topics = []
            for entry in data:
                if 'topics' in entry and isinstance(entry['topics'], list):
                    all_topics.extend(entry['topics'])
            
            logger.info(f"Extracted {len(all_topics)} topics from the JSON structure")
        except json.JSONDecodeError as e:
            logger.error(f"Failed to parse JSON: {str(e)}")
            raise
            
        # For now, we don't have an overview, so return an empty string
        overview = ""
        
        return overview, all_topics
    
    def split_long_message(self, message: str) -> List[str]:
        """
        Split a long message into smaller chunks to comply with Discord's character limit.
        
        Args:
            message: The message to split
            
        Returns:
            List of message chunks, each within the character limit
        """
        if len(message) <= self.MAX_MESSAGE_LENGTH:
            return [message]
        
        chunks = []
        current_chunk = ""
        
        # Split by lines first for more natural breaks
        lines = message.split('\n')
        
        for line in lines:
            # If adding this line would exceed the limit, store current chunk and start a new one
            if len(current_chunk) + len(line) + 1 > self.MAX_MESSAGE_LENGTH:
                # If the line itself is too long, we need to split it
                if len(line) > self.MAX_MESSAGE_LENGTH:
                    # If current chunk is not empty, add it to chunks
                    if current_chunk:
                        chunks.append(current_chunk)
                        current_chunk = ""
                    
                    # Split the long line into chunks
                    remaining = line
                    while remaining:
                        # Find a good breaking point (space) near the limit
                        break_point = self.MAX_MESSAGE_LENGTH
                        if len(remaining) > self.MAX_MESSAGE_LENGTH:
                            # Try to find the last space before the limit
                            last_space = remaining[:self.MAX_MESSAGE_LENGTH].rfind(' ')
                            if last_space > 0:  # If space found, break there
                                break_point = last_space + 1
                        
                        chunks.append(remaining[:break_point])
                        remaining = remaining[break_point:]
                else:
                    # Current chunk is full, add it to chunks and start new with this line
                    chunks.append(current_chunk)
                    current_chunk = line
            else:
                # Add line to current chunk
                if current_chunk:
                    current_chunk += '\n' + line
                else:
                    current_chunk = line
        
        # Add the last chunk if it's not empty
        if current_chunk:
            chunks.append(current_chunk)
        
        return chunks
    
    def format_topic(self, topic_data: Dict[str, Any]) -> str:
        """
        Format a topic dictionary into a readable Discord message.
        
        Args:
            topic_data: Dictionary containing topic information
            
        Returns:
            Formatted string for Discord message
        """
        # Check which format the topic is in based on keys
        if 'topic' in topic_data:
            # Start with the topic title
            message = f"**{topic_data['topic']}**"
            
            # Add sources on the same line if available
            if 'sources' in topic_data and isinstance(topic_data['sources'], list) and topic_data['sources']:
                message += "  -  "
                source_links = []
                for i, source in enumerate(topic_data['sources']):
                    # Create markdown link format for Discord
                    source_links.append(f"[Source]({source})")
                
                message += " | ".join(source_links)
            
            # Add a blank line before details
            message += "\n\n"
            
            # Handle 'details' array (always present, even if just one item)
            if 'details' in topic_data and isinstance(topic_data['details'], list):
                for detail in topic_data['details']:
                    message += f"     â€¢ {detail}\n"
            else:
                # Fallback in case the format is unexpected
                message += "     No details provided for this topic.\n"
            
            # Add an extra blank line at the end to ensure separation between topics
            message += "\u200B"
                    
            return message
            
        # Fall back to just returning the data as a formatted string if structure is unknown
        return f"**Topic Information**\n\n{json.dumps(topic_data, indent=2)}\n\n"
        
    async def publish_summary(self, file_path: str, include_overview: bool = True, delay: float = 1.0) -> Dict[str, Any]:
        """
        Publish a summary to Discord.
        
        Args:
            file_path: Path to the summary file
            include_overview: Whether to include the overview as the first message
            delay: Delay between messages in seconds to avoid rate limiting
            
        Returns:
            Dictionary with statistics about the publish operation
        """
        await self.client.wait_until_ready()
        
        # Get target server and channel
        server = self.client.get_guild(self.server_id)
        if not server:
            raise ValueError(f"Server with ID {self.server_id} not found")
        
        channel = server.get_channel(self.channel_id)
        if not channel:
            raise ValueError(f"Channel with ID {self.channel_id} not found in server {server.name}")
        
        logger.info(f"Publishing to channel #{channel.name} in server {server.name}")
        
        # Parse the summary file
        overview, topics = await self.parse_summary_file(file_path)
        
        # Stats to track the operation
        stats = {
            'messages_sent': 0,
            'topics_sent': 0,
            'errors': 0
        }
        
        try:
            # Send the overview if requested
            if include_overview and overview:
                # If overview is too long, split it
                if len(overview) > self.MAX_MESSAGE_LENGTH:
                    overview_chunks = self.split_long_message(overview)
                    for chunk in overview_chunks:
                        await channel.send(chunk)
                        stats['messages_sent'] += 1
                        await asyncio.sleep(delay)
                else:
                    await channel.send(overview)
                    stats['messages_sent'] += 1
                    await asyncio.sleep(delay)
            
            # Send each topic
            for topic_data in topics:
                # Format the topic into a readable message
                formatted_topic = self.format_topic(topic_data)
                
                # If topic is too long, split it
                if len(formatted_topic) > self.MAX_MESSAGE_LENGTH:
                    topic_chunks = self.split_long_message(formatted_topic)
                    for chunk in topic_chunks:
                        await channel.send(chunk)
                        stats['messages_sent'] += 1
                        await asyncio.sleep(delay)
                else:
                    await channel.send(formatted_topic)
                    stats['messages_sent'] += 1
                    await asyncio.sleep(delay)
                
                stats['topics_sent'] += 1
            
            logger.info(f"Successfully sent {stats['topics_sent']} topics in {stats['messages_sent']} messages")
        
        except discord.errors.Forbidden:
            error_msg = f"Bot doesn't have permission to send messages to channel #{channel.name}"
            logger.error(error_msg)
            stats['errors'] += 1
            raise PermissionError(error_msg)
        
        except Exception as e:
            logger.error(f"Error publishing summary: {str(e)}")
            stats['errors'] += 1
            raise
        
        return stats
    
    async def start(self, file_path: str, include_overview: bool = True, delay: float = 1.0) -> Dict[str, Any]:
        """
        Start the publisher and publish the summary.
        
        Args:
            file_path: Path to the summary file
            include_overview: Whether to include the overview as the first message
            delay: Delay between messages in seconds
            
        Returns:
            Dictionary with statistics about the publish operation
        """
        # Create a future to hold the result
        result_future = asyncio.Future()
        
        # Set up a task to publish the summary after the bot is ready
        async def publish_task():
            try:
                await self.is_ready.wait()
                stats = await self.publish_summary(file_path, include_overview, delay)
                result_future.set_result(stats)
            except Exception as e:
                result_future.set_exception(e)
            finally:
                await self.client.close()
        
        # Start the task
        asyncio.create_task(publish_task())
        
        try:
            # Start the bot
            await self.client.start(self.token)
        except Exception as e:
            if not result_future.done():
                result_future.set_exception(e)
            raise
        
        return await result_future

def parse_args():
    """Parse command-line arguments."""
    parser = argparse.ArgumentParser(description="Publish Discord summary to a channel")
    
    parser.add_argument(
        "summary_path",
        type=str,
        help="Path to the summary JSON file"
    )
    
    parser.add_argument(
        "--test-mode",
        action="store_true",
        help="Use test server and channel IDs from environment variables"
    )
    
    parser.add_argument(
        "--include-overview",
        action="store_true",
        default=True,
        help="Include the overview paragraph in the published messages"
    )
    
    parser.add_argument(
        "--delay",
        type=float,
        default=1.0,
        help="Delay between messages in seconds to avoid rate limiting"
    )
    
    return parser.parse_args()

async def run_publisher(args):
    """Run the summary publisher with the provided arguments."""
    publisher = SummaryPublisher(test_mode=args.test_mode)
    
    try:
        stats = await publisher.start(
            args.summary_path,
            include_overview=args.include_overview,
            delay=args.delay
        )
        
        print("\nSummary Publishing Complete!")
        print(f"Messages sent: {stats['messages_sent']}")
        print(f"Topics sent: {stats['topics_sent']}")
        if stats['errors'] > 0:
            print(f"Errors encountered: {stats['errors']}")
    except Exception as e:
        print(f"Error: {str(e)}")

def main():
    """Main entry point."""
    args = parse_args()
    asyncio.run(run_publisher(args))

if __name__ == "__main__":
    main() 