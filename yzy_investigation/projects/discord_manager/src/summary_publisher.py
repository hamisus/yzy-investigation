"""Discord Summary Publisher module.

This module provides functionality to publish Discord summary bullet points 
to a specified Discord channel, taking summaries generated by the message_summarizer
and posting them as individual messages for improved readability.
"""

import os
import sys
import asyncio
import re
from pathlib import Path
from typing import List, Dict, Any, Optional, Tuple
import argparse
import logging
from datetime import datetime, timedelta

import discord
from dotenv import load_dotenv

# Add the project root to the Python path
project_root = Path(__file__).parent.parent.parent.parent
sys.path.append(str(project_root))

# Configure logging
logging.basicConfig(
    level=logging.INFO,
    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s'
)
logger = logging.getLogger(__name__)

class SummaryPublisher:
    """Class for publishing summary bullet points to Discord channels."""
    
    def __init__(
        self, 
        token: Optional[str] = None,
        server_id: Optional[int] = None,
        channel_id: Optional[int] = None,
        test_mode: bool = True
    ):
        """
        Initialize the SummaryPublisher.
        
        Args:
            token: Discord bot token. If None, will use DISCORD_BOT_TOKEN env var.
            server_id: Discord server ID. If None, will use appropriate env var.
            channel_id: Discord channel ID. If None, will use appropriate env var.
            test_mode: If True, use test server and channel IDs from env vars.
        """
        # Load environment variables if needed
        load_dotenv()
        
        # Set up Discord bot token
        self.token = token or os.environ.get("DISCORD_BOT_TOKEN")
        if not self.token:
            raise ValueError("Discord bot token not provided and DISCORD_BOT_TOKEN not set in environment")
        
        # Set up server and channel IDs based on test mode
        if test_mode:
            self.server_id = server_id or int(os.environ.get("DISCORD_SERVER_ID_TEST", 0))
            self.channel_id = channel_id or int(os.environ.get("DISCORD_CHANNEL_ID_TEST", 0))
            logger.info("Running in TEST mode")
        else:
            self.server_id = server_id or int(os.environ.get("DISCORD_SERVER_ID", 0))
            self.channel_id = channel_id or int(os.environ.get("DISCORD_CHANNEL_ID", 0))
        
        if self.server_id == 0:
            raise ValueError(f"Discord server ID not provided and {'DISCORD_SERVER_ID_TEST' if test_mode else 'DISCORD_SERVER_ID'} not set in environment")
        
        if self.channel_id == 0:
            raise ValueError(f"Discord channel ID not provided and {'DISCORD_CHANNEL_ID_TEST' if test_mode else 'DISCORD_CHANNEL_ID'} not set in environment")
        
        # Configure intents for Discord client
        intents = discord.Intents.default()
        intents.message_content = True
        self.client = discord.Client(intents=intents)
        self.is_ready = asyncio.Event()
        self.test_mode = test_mode
        
        # Set up an event for when the client is ready
        @self.client.event
        async def on_ready():
            logger.info(f"Bot logged in as {self.client.user}")
            self.is_ready.set()
    
    async def parse_summary_file(self, file_path: str) -> Tuple[str, List[str]]:
        """
        Parse a summary file and extract bullet points.
        
        Args:
            file_path: Path to the summary file
            
        Returns:
            Tuple containing (overview text, list of bullet points)
        """
        with open(file_path, 'r', encoding='utf-8') as f:
            content = f.read()
        
        # Extract overview (first paragraph before bullet points)
        overview_match = re.search(r'^(.+?)(?=\n-|\Z)', content, re.DOTALL)
        overview = overview_match.group(1).strip() if overview_match else ""
        
        # Extract bullet points (lines starting with - or *)
        bullet_points = re.findall(r'^(?:[-*]\s+.+)(?:\n\s+.*)*', content, flags=re.MULTILINE)
        
        # Clean up bullet points
        bullet_points = [point.strip() for point in bullet_points if point.strip()]
        
        logger.info(f"Extracted {len(bullet_points)} bullet points from summary")
        return overview, bullet_points
    
    async def publish_summary(self, file_path: str, include_overview: bool = True, delay: float = 1.0) -> Dict[str, Any]:
        """
        Publish a summary to Discord.
        
        Args:
            file_path: Path to the summary file
            include_overview: Whether to include the overview as the first message
            delay: Delay between messages in seconds to avoid rate limiting
            
        Returns:
            Dictionary with statistics about the publish operation
        """
        await self.client.wait_until_ready()
        
        # Get target server and channel
        server = self.client.get_guild(self.server_id)
        if not server:
            raise ValueError(f"Server with ID {self.server_id} not found")
        
        channel = server.get_channel(self.channel_id)
        if not channel:
            raise ValueError(f"Channel with ID {self.channel_id} not found in server {server.name}")
        
        logger.info(f"Publishing to channel #{channel.name} in server {server.name}")
        
        # Parse the summary file
        overview, bullet_points = await self.parse_summary_file(file_path)
        
        # Stats to track the operation
        stats = {
            'messages_sent': 0,
            'bullet_points_sent': 0,
            'errors': 0
        }
        
        try:
            # Send the overview if requested
            if include_overview and overview:
                await channel.send(overview)
                stats['messages_sent'] += 1
                await asyncio.sleep(delay)  # Pause to avoid rate limiting
            
            # Send each bullet point
            for bullet in bullet_points:
                await channel.send(bullet)
                stats['messages_sent'] += 1
                stats['bullet_points_sent'] += 1
                await asyncio.sleep(delay)  # Pause to avoid rate limiting
            
            logger.info(f"Successfully sent {stats['bullet_points_sent']} bullet points")
        
        except discord.errors.Forbidden:
            error_msg = f"Bot doesn't have permission to send messages to channel #{channel.name}"
            logger.error(error_msg)
            stats['errors'] += 1
            raise PermissionError(error_msg)
        
        except Exception as e:
            logger.error(f"Error publishing summary: {str(e)}")
            stats['errors'] += 1
            raise
        
        return stats
    
    async def start(self, file_path: str, include_overview: bool = True, delay: float = 1.0) -> Dict[str, Any]:
        """
        Start the publisher and publish the summary.
        
        Args:
            file_path: Path to the summary file
            include_overview: Whether to include the overview as the first message
            delay: Delay between messages in seconds
            
        Returns:
            Dictionary with statistics about the publish operation
        """
        # Create a future to hold the result
        result_future = asyncio.Future()
        
        # Set up a task to publish the summary after the bot is ready
        async def publish_task():
            try:
                await self.is_ready.wait()
                stats = await self.publish_summary(file_path, include_overview, delay)
                result_future.set_result(stats)
            except Exception as e:
                result_future.set_exception(e)
            finally:
                await self.client.close()
        
        # Start the task
        asyncio.create_task(publish_task())
        
        try:
            # Start the bot
            await self.client.start(self.token)
        except Exception as e:
            if not result_future.done():
                result_future.set_exception(e)
            raise
        
        return await result_future

def parse_args():
    """Parse command-line arguments."""
    parser = argparse.ArgumentParser(description="Publish Discord summary to a channel")
    
    parser.add_argument(
        "summary_path",
        type=str,
        help="Path to the summary markdown file"
    )
    
    parser.add_argument(
        "--test-mode",
        action="store_true",
        help="Use test server and channel IDs from environment variables"
    )
    
    parser.add_argument(
        "--include-overview",
        action="store_true",
        default=True,
        help="Include the overview paragraph in the published messages"
    )
    
    parser.add_argument(
        "--delay",
        type=float,
        default=1.0,
        help="Delay between messages in seconds to avoid rate limiting"
    )
    
    return parser.parse_args()

async def run_publisher(args):
    """Run the summary publisher with the provided arguments."""
    publisher = SummaryPublisher(test_mode=args.test_mode)
    
    try:
        stats = await publisher.start(
            args.summary_path,
            include_overview=args.include_overview,
            delay=args.delay
        )
        
        print("\nSummary Publishing Complete!")
        print(f"Messages sent: {stats['messages_sent']}")
        print(f"Bullet points sent: {stats['bullet_points_sent']}")
        if stats['errors'] > 0:
            print(f"Errors encountered: {stats['errors']}")
    except Exception as e:
        print(f"Error: {str(e)}")

def main():
    """Main entry point."""
    args = parse_args()
    asyncio.run(run_publisher(args))

if __name__ == "__main__":
    main() 